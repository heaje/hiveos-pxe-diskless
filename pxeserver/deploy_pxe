#!/bin/bash

BLACK='\033[0;30m'
DGRAY='\033[1;30m'
RED='\033[0;31m'
BRED='\033[1;31m'
GREEN='\033[0;32m'
BGREEN='\033[1;32m'
YELLOW='\033[0;33m'
BYELLOW='\033[1;33m'
BLUE='\033[0;34m'
BBLUE='\033[1;34m'
PURPLE='\033[0;35m'
BPURPLE='\033[1;35m'
CYAN='\033[0;36m'
BCYAN='\033[1;36m'
LGRAY='\033[0;37m'
WHITE='\033[1;37m'
NOCOLOR='\033[0m'

SCRIPT_PATH=$(dirname $0)
cd $SCRIPT_PATH
mydir=$(pwd)

### Some code for nvidia manipulation (check|list|download) based on nvidia-driver-update ^)

dist=$1
docker_build_cmd="docker compose --progress=plain build"

LOG_FILE=$(basename $0).log
DIR=$(pwd)/build/$dist/_fs

kern_ver=$(dpkg -I kernel/linux-image-*.deb | grep Package: | sed -r 's/.*linux-image-//')

[[ -e server.conf ]] && source server.conf

function echo2() {
    name=$(basename $0)
    pad=$(echo -n "$1" | sed -e :a -e 's/^.\{1,45\}$/&./;ta')
    echo -ne ${BCYAN}[$(date +'%d/%m/%Y %H:%M:%S')][${name^^}]${NOCOLOR} ${YELLOW}$pad${NOCOLOR}
}

function echo_ok() {
    echo -e "${GREEN}[OK]${NOCOLOR}"
}

function echo_fail() {
    echo -e "${RED}[FAIL]${NOCOLOR}"
    exit 1
}

function show_help() {
    echo "Usage:
  deploy_pxe ubuntu20 --build           create latest Ubuntu 20.04 image
  deploy_pxe ubuntu20 --selfupgrade     just upgrade Hive package and repack rootfs image
  deploy_pxe ubuntu20 --upgrade         upgrade all and repack rootfs image
  deploy_pxe ubuntu20 --chroot          chroot into rootfs (for manual actions)
  deploy_pxe ubuntu20 --initrd          rebuild initramfs image
  deploy_pxe ubuntu20 --remove          delete rootfs folder

Nvidia drivers:
  deploy_pxe nvidia --list              list available driver versions
  deploy_pxe nvidia --build <VER>       build driver specific version ( e.g. 515 or 515.105 or 515.105.01)

AMD OpenCL:
  deploy_pxe opencl --list              list available driver versions
  deploy_pxe opencl --build <VER>       build specific version (for now 5.4 only)
"
}

##NVIDIA PART
CUDA_VER=(
    12.2 535.54.03
    12.0 525.60.13
    11.8 520.56.06
    11.7 515.43.04
    11.6 510.39.01
)

function get_cuda_version() { # @driver_version, returns cuda_version
    local ver="$1"
    readarray -t ver_arr < <(echo -e "${ver//./$'\n'}\n0\n0")
    cuda_version=

    for ((i = 1; i < ${#CUDA_VER[@]}; i += 2)); do
        readarray -t ref_arr < <(echo -e "${CUDA_VER[$i]//./$'\n'}\n0\n0")
        if [[ ${ver_arr[0]} -gt ${ref_arr[0]} ||
            (${ver_arr[0]} -eq ${ref_arr[0]} && ${ver_arr[1]#0} -gt ${ref_arr[1]#0}) ||
            (${ver_arr[0]} -eq ${ref_arr[0]} && ${ver_arr[1]#0} -eq ${ref_arr[1]#0} && ${ver_arr[2]#0} -ge ${ref_arr[2]#0}) ]]; then
            cuda_version=${CUDA_VER[$((i - 1))]}
            return 0
        fi
    done

    return 1
}

function list_packages() {
    get_versions
    if [[ $? -eq 0 ]]; then
        local last=
        local cuda=
        local incompat=
        [[ $force -ne 1 ]] && level=1 || level=2
        for drv in "${versions[@]}"; do
            incompat=0
            [[ $incompat -ge $level ]] && continue
            get_cuda_version "$drv"
            if [[ "$cuda" != "$cuda_version" ]]; then
                [[ ! -z $cuda ]] && echo ""
                cuda="$cuda_version"
                echo -e "${PURPLE}CUDA $cuda${NOCOLOR}"
                last=
            fi
            this="${drv%%.*}"
            if [[ "$this" > "500" ]]; then
                if [[ "$last" != "$this" || -z "$last" ]]; then
                    [[ ! -z "$last" ]] && echo -e ""
                    last="$this"
                    echo -ne "  ${WHITE}$this${NOCOLOR}"
                fi

                if [[ "$current_version" == "$drv" ]]; then
                    echo -ne "      ${BGREEN}$drv${NOCOLOR}"
                elif [[ $incompat -ne 0 ]]; then
                    echo -ne "      ${RED}$drv${NOCOLOR}"
                elif [[ -f "${DRVPATH}${DRVPATTERN}${drv}.run" ]]; then
                    echo -ne "      ${CYAN}$drv${NOCOLOR}"
                else
                    echo -ne "      $drv"
                fi
            fi
        done
        echo ""
    fi

    get_stable
}

function check_package() { # @filename
    #local basename=$(basename $1)
    [[ ! -f "${DRVPATH}$1" ]] && return 1
    #echo -e ""
    echo2 "Checking package integrity" && echo ""
    local exitcode=1
    # check size. zero file exits with 0
    local size=$(stat -c %s "${DRVPATH}$1")
    if [[ $size -gt 1000 ]]; then
        chmod +x "${DRVPATH}$1"
        "${DRVPATH}$1" --check
        exitcode=$?
    fi
    [[ $exitcode -ne 0 ]] && echo -e "${RED}> Check failed${NOCOLOR}"
    return $exitcode
}

function get_url() { # @version or @url, returns $url and $url_tesla
    url_tesla=
    # latest stable
    if [[ -z "$1" ]]; then
        get_latest || return $?
        url="${DRVURL}${DRVPATTERN}${latest_version}.run"
    # 440.95.01 & 123.45 formats
    elif [[ "$1" =~ ^[0-9]{3}\.[0-9]{2,3}\.[0-9]{2}$ || "$1" =~ ^[0-9]{3}\.[0-9]{2,3}$ ]]; then
        local last=
        get_versions
        if [[ $? -eq 0 ]]; then
            for drv in "${versions[@]}"; do
                [[ "$drv" == "$1" || "${drv%.*}" == "$1" ]] && last="$drv" && break
            done
        fi
        if [[ ! -z "$last" ]]; then
            url="${DRVURL}${DRVPATTERN}${last}.run"
        else
            echo -e "${YELLOW}> ${WHITE}$1${YELLOW} was not found in the list. Trying to get it from NVIDIA${NOCOLOR}"
            url="${DRVNVIDIAURL}$1/${DRVPATTERN}$1.run"
            [[ "$1" =~ ^[0-9]{3}\.[0-9]{2,3}\.[0-9]{2}$ ]] &&
                url_tesla="https://uk.download.nvidia.com/tesla/$1/${DRVPATTERN}$1.run"
        fi
    # 123 format
    elif [[ "$1" =~ ^[0-9]{3}$ ]]; then
        get_versions || return $?
        local last=
        for drv in "${versions[@]}"; do
            [[ "${drv%%.*}" == "$1" ]] && last="$drv" && continue
            [[ ! -z "$last" ]] && break
        done
        [[ -z "$last" ]] && echo -e "${RED}> Unable to find latest driver version for $1 series${NOCOLOR}" && return 1
        echo2 "Latest driver for $1 series - ${WHITE}$last${NOCOLOR}" && echo ""
        url="${DRVURL}${DRVPATTERN}${last}.run"
    # url
    else
        url="$1"
    fi
    [[ -z "$url" ]] && return 1
    return 0
}

function get_package() { # @url or @file, returns $package
    local exitcode=0
    local url="$1"

    package=$(basename "$url")
    [[ -z "$package" ]] && echo -e "${RED}> No file name in $url${NOCOLOR}" && return 1

    # check if file already exists and it is good
    local exist=0
    if [[ -f "${DRVPATH}$package" ]]; then
        echo -e ""
        echo2 "Driver package already exists" && echo ""
        check_package "$package" && return 0
        exist=1
    fi

    # local file
    if [[ "$url" != ftp* && "$url" != http* ]]; then
        #[[ ! -f $url ]] &&  echo -e "${RED} Unable to get from $url" && return 1
        realpath=$(realpath "$url")
        [[ "$realpath" == "${DRVPATH}$package" ]] && return 1
        cp "$url" "${DRVPATH}$package"
        [[ $? -ne 0 ]] && echo -e "${RED}> Unable to get file from - ${WHITE}$url${NOCOLOR}" && return 1
        check_package "$package"
        return $?
    fi

    for i in {1..2}; do
        # download file. resume if exists
        echo -e ""
        echo -e "${CYAN}> Downloading - ${WHITE}$url${NOCOLOR}"
        [ ! -t 1 ] && verb="-nv" # reduce log in non-interactive mode
        wget $verb --no-check-certificate -T $TIMEOUT -t $RETRY -c -P ${DRVPATH} $url 2>&1
        exitcode=$?
        [[ $exitcode -ne 0 ]] && echo -e "${RED}> Download error ($exitcode)${NOCOLOR}" && return $exitcode

        # check it again
        check_package "$package" && return 0

        # if file existed before, delete it and try download again. it would help if it was already broken
        [[ $exist -eq 0 ]] && return 1
        echo -e ""
        echo -e "${YELLOW}> File is broken. Deleting it and downloading again${NOCOLOR}"
        unlink "${DRVPATH}$package"
        exist=0
    done
}

versions=()
function get_versions() { # returns $versions
    [[ ${#versions[@]} -gt 0 ]] && return 0
    echo2 "Loading drivers list${NOCOLOR}"
    local list=
    if [[ "$DRVURL" == "$DRVNVIDIAURL" ]]; then
        list=$(curl -sLk --connect-timeout $TIMEOUT --retry $RETRY $DRVNVIDIAURL) &&
            readarray -t versions < <(echo "$list" | grep -oP "\>\K[0-9]+\.[0-9\.]+" | sort -u -V)
    else
        list=$(curl -sLk --connect-timeout $TIMEOUT --retry $RETRY $DRVURL) &&
            readarray -t versions < <(echo "$list" | grep -oP "$DRVREGEXP" | sort -u -V)
    fi
    [[ ${#versions[@]} -eq 0 ]] && echo -e "${RED}Failed${NOCOLOR}" && return 1
    echo -e "${GREEN}${#versions[@]}${NOCOLOR}"
    return 0
}

function get_stable() { # returns $stable_version
    echo -en "${WHITE}> Stable version - ${NOCOLOR}"
    if [[ "$DRVURL" == "$DRVNVIDIAURL" ]]; then
        local list=$(curl -sLk --connect-timeout $TIMEOUT --retry $RETRY ${DRVNVIDIAURL}latest.txt)
    else
        local list=$(curl -sLk --connect-timeout $TIMEOUT --retry $RETRY ${DRVURL}VERSIONS.txt)
    fi
    [[ -z "$list" ]] && echo -e "${RED}Failed${NOCOLOR}" && return 1
    stable_version=$(echo "$list" | grep -oP "$DRVREGEXP" | tail -n 1)
    [[ -z "$stable_version" ]] && echo -e "${RED}Error${NOCOLOR}" && return 2
    get_cuda_version "$stable_version" &&
        echo -e "${WHITE}${stable_version} ${PURPLE}(CUDA $cuda_version)${NOCOLOR}" ||
        echo -e "${WHITE}${stable_version}${NOCOLOR}"
    return 0
}

function build_driver() { # @url or @file, @force_install
    # it must exist
    get_url "$1" || return $?

    # check compatibility
    local ver=$(echo "$url" | grep -oP "${DRVREGEXP}")

    build_kernel
    # Build NVIDIA Driver
    echo2 "Building NVIDIA Driver version ${ver}..."
    ${docker_build_cmd} --build-arg "nvidia_url=${url}" --build-arg "nvidia_version=${ver}" hiveos-nvidia &>>$LOG_FILE
    [[ $? -ne 0 ]] && echo_fail || echo_ok

    mkdir -p build/nvidia
    echo2 "Copying NVIDIA Driver tarball..."
    local cont_temp_id=$(docker create --rm hiveos-nvidia)
    docker cp -L ${cont_temp_id}:/nvidia/nvidia-${ver}.tar.xz build/nvidia/ &>>$LOG_FILE
    [[ $? -ne 0 ]] && echo_fail || echo_ok
    docker rm -f ${cont_temp_id} 1>/dev/null
}

create_initrd() {
    echo2 "Copy initramfs config..."
    cp -r configs/initramfs-tools/* ${DIR}/etc/initramfs-tools/
    echo_ok
    echo2 "Create initramfs image..."
    #kern_ver=$(basename ${DIR}/lib/modules/*)
    chroot ${DIR} mkinitramfs -c xz -o /boot/initrd-ram.img ${kern_ver}
    echo_ok
    echo2 "Create symlink..."
    mkdir -p build/$dist/boot
    cp -r ${DIR}/boot/initrd-ram.img build/$dist/boot/initrd-ram.img
    cp -r ${DIR}/boot/vmlinuz-${kern_ver} build/$dist/boot/vmlinuz
    [[ ! -d $mydir/hiveramfs/boot ]] && mkdir -p $mydir/hiveramfs/boot
    rm -rf $mydir/hiveramfs/boot/$dist && ln -sf $mydir/build/$dist/boot/vmlinuz $mydir/hiveramfs/boot/$dist
    rm -rf $mydir/hiveramfs/boot/$dist.img && ln -sf $mydir/build/$dist/boot/initrd-ram.img $mydir/hiveramfs/boot/$dist.img
    echo_ok
}

list_opencl() {
    echo "Not implemented yet."
}

build_opencl() {
    [[ "$#" -eq 0 ]] && local ver=$DEFAULT_OCL_VER || local ver=$1
    echo2 "Building amd-opencl-${ver}.tar.xz..."
    ${docker_build_cmd} --build-arg opencl_version=${ver} hiveos-opencl &>>$LOG_FILE
    [[ $? -ne 0 ]] && echo_fail || echo_ok

    echo2 "Copying archive amd-opencl-${ver}.tar.xz..."
    [[ ! -d build/opencl ]] && mkdir -p build/opencl
    local cont_temp_id=$(docker create --rm hiveos-opencl)
    docker cp ${cont_temp_id}:/opencl/amd-opencl-${ver}.tar.xz build/opencl/amd-opencl-$ver.tar.xz &>>$LOG_FILE
    [[ $? -ne 0 ]] && echo_fail || echo_ok
    docker rm -f ${cont_temp_id} 1>/dev/null &>>$LOG_FILE

    echo2 "Create symlink..."
    ln -sf build/opencl/amd-opencl-${ver}.tar.xz hiveramfs/
    [[ $? -ne 0 ]] && echo_fail || echo_ok
}

remove_opencl() {
    echo "Not implemented yet."
}

build_fs() {
    echo2 "Building Filesystem container..."
    ${docker_build_cmd} hiveos &>>$LOG_FILE
    [[ $? -eq 0 ]] && echo_ok || echo_fail

    [[ ! -d hiveramfs/boot ]] && mkdir -p hiveramfs/boot
    rm -f "hiveramfs/boot/${dist}" && ln -sf "${mydir}/build/$dist/boot/vmlinuz" "hiveramfs/boot/${dist}"
    rm -f "hiveramfs/boot/${dist}.img" && ln -sf "${mydir}/build/${dist}/boot/initrd-ram.img" "hiveramfs/boot/${dist}.img"
}

build_kernel() {
    echo2 "Building Kernel container..."
    ${docker_build_cmd} --pull hiveos-kernel &>>$LOG_FILE
    [[ $? -eq 0 ]] && echo_ok || echo_fail

    echo2 "Extracting Kernel and initramfs..."
    mkdir -p "build/${dist}/boot"
    local cont_temp_id=$(docker create --rm hiveos-kernel)
    docker cp -L ${cont_temp_id}:/boot/vmlinuz build/${dist}/boot/vmlinuz &>>$LOG_FILE
    docker cp ${cont_temp_id}:/boot/initrd-ram.img build/${dist}/boot/initrd-ram.img &>>$LOG_FILE
    docker rm -f ${cont_temp_id} 1>/dev/null
    [[ $? -eq 0 ]] && echo_ok || echo_fail
}

install_kernel() {
    echo2 "Install linux kernel..."
    mkdir -p $DIR/kernel/
    mkdir -p build/_kernel/$kern_ver
    cp -r kernel/*.deb $DIR/kernel/
    for file in $DIR/kernel/*; do
        chroot $DIR dpkg -i /kernel/$(basename $file) &>>$LOG_FILE
        dpkg -x kernel/$(basename $file) build/_kernel/$kern_ver/ &>>$LOG_FILE
    done
    echo_ok
}

extract_kernel() {
    echo2 "Extract linux kernel..."
    mkdir -p $DIR/kernel/
    mkdir -p build/_kernel/$kern_ver
    for file in kernel/*; do
        dpkg -x kernel/$(basename $file) build/_kernel/$kern_ver/ &>>$LOG_FILE
    done
    echo_ok
}

deploy_fs() {
    local filepath=build/$dist/$dist.tar.xz

    echo2 "Saving to $filepath ..."
    local cont_temp_id=$(docker create --rm hiveos)
    docker export "${cont_temp_id}" | pixz -9 -e >$filepath
    [[ $? -ne 0 ]] && echo_fail || echo_ok
    docker rm -f ${cont_temp_id} 1>/dev/null &>>$LOG_FILE
    echo2 "Create symlink ..."
    rm -f hiveramfs/$dist.tar.xz && ln -s ../$filepath hiveramfs/$dist.tar.xz
    [[ $? -ne 0 ]] && echo_fail || echo_ok
}

echo ""
echo ""

case $dist in
    ubuntu18)
        suite=bionic
        echo -e "${RED} Ubuntu 18.04 ($suite) image is deprecated.${NOCOLOR}"
        LOG_FILE="build-${suite}.log"
        docker_build_cmd="${docker_build_cmd} --build-arg ubuntu_version=18.04"
        shift
        ;;
    ubuntu20)
        suite=focal
        LOG_FILE="build-${suite}.log"
        docker_build_cmd="${docker_build_cmd} --build-arg ubuntu_version=20.04"
        shift
        ;;
    nvidia)
        DOWNLOAD_URL=http://download.hiveos.farm
        DRVURL=$DOWNLOAD_URL/drivers/
        DRVPATH=build/nvidia/
        TIMEOUT=10
        RETRY=3
        #mkdir -p build/$dist
        DRVPATTERN="NVIDIA-Linux-x86_64-"
        DRVREGEXP="${DRVPATTERN}\K[0-9\.]+(?=\.run)"
        DRVNVIDIAURL="https://download.nvidia.com/XFree86/Linux-x86_64/"
        LOG_FILE="nvidia.log"
        shift
        case $1 in
            --list)
                list_packages
                exit 0
                ;;
            --build)
                shift
                build_driver "$1"
                exit $?
                ;;
            *)
                show_help
                exit 1
                ;;
        esac
        ;;
    opencl)
        shift
        case $1 in
            --list)
                list_opencl
                exit $?
                ;;
            --build)
                shift
                build_opencl $1
                exit $?
                ;;
            --remove)
                shift
                remove_opencl $1
                exit $?
                ;;
            *)
                show_help
                ;;
        esac
        ;;
    *)
        show_help
        exit 1
        ;;
esac

case $1 in
    --chroot)
        docker run -it --rm hiveos /bin/bash
        exit $?
        ;;
    --build)
        build_kernel
        build_fs
        deploy_fs
        ;;
    --build-kernel)
        build_kernel
        ;;
    --remove)
        docker rmi hiveos hiveos-kernel
        remove_fs
        ;;
    *)
        show_help
        exit 1
        ;;
esac
